
## 《Java并发编程实战》 笔记


##### 2.1 线程安全性
线程安全性，核心是正确性。 正确性的定义"所见即所知"。

线程安全性的定义: 当多个线程访问某个类，这个类始终都能表现正确的行为(结果)。

无状态对象一定是线程安全(多个线程不会相互影响)

- 活跃性: 某个操作无法继续执行下去，就会发生活跃性问题(例如: 无意造成的死循环/死锁等场景)

##### 2.2 原子性

高级语言中 ++count 看上去是一个操作，但这个操作并非原子的。

实际上包含三个独立的操作: "读取-修改-写入"的操作序列，并且结果依赖于之前的状态

- 竞态条件(有序性) 定义: 由于不可控的执行时许而出现不正确的结果。

- 复合操作: 将 ++ count["读取-修改-写入"] 一组必须以原子方式执行的操作以确保线程安全性。



##### 2.3 加锁机制

加锁机制，在多个线程之间操作，都要保证状态的一致性。(保证不变性条件)

- 要保证状态的一致性，需要在单个原子操作中更新所有相关的状态变量

- 内置锁: 同步代码块（Synchronized）. 作为锁的对象引用(Java对象);由这个锁保护代码块;
    
    - 内置锁是一种互斥锁，最多只有一个线程能持有该锁

- 重入: 当某个线程持有该对象锁，再次请求该对象锁是可以成功的。
   
    - Java中获取对象锁的单位是「线程」不是以「调用」为单位
     
    - 参考: https://www.cnblogs.com/cielosun/p/6684775.html

##### 2.4 用锁保护状态

锁能够使多个线程以此已独占的方式访问对象，并不会并发访问。

- 对于共享与可变的变量都应该由一个锁来保护。例如: 线程安全类Vector,使用对象锁进行同步，不会发生并发访问

- 虽然单个sychronized方法可以确保单个操作的原子性，但对于多个操作合并的复合操作，还需要额外的加锁机制。

##### 2.5 活跃性与性能

- 使用同步代码块，要"足够短" 并且要权衡 安全性、简单行和性能。

- 执行时间过长或无法快速完成的操作(例如: I/O)一定不要持有锁，否则会带来活跃性和性能问题。

##### 3.1 可见性

定义: 当一个线程修改了对象状态后,其他线程能够看到发生的变化。但如果没有同步，这种情况无法实现。所以确保多个线程之间对内存写入操作的可见性，必须使用同步机制。

- 加锁不仅局限于互斥行为，还包括内存可见性. 为了确保所有线程都能看到共享变量的最新值，所有执行读操作或写操作的线程都必须在同一个锁上同步。

- volatile变量，用于确保将变量的更新操作通知其他线程
    
   - 场景上: 作为某个操作完成、发生中断的状态标志。表示状态信息。
   
   - 使用要求: https://www.ibm.com/developerworks/cn/java/j-jtp06197.html
   
- 加锁机制即可以确保可见性又可以确保原子性，而volatile 变量只能确保 可见性。


##### 3.2 发布与逸出

「发布(Publish)」对象定义: 当前对象能够在当前作用域之外的代码中使用。（例如:将对象的引用保存到一个公共静态变量中，以便任何类和线程都能看见该对象）
```java
public class Test{
   public static Set<Test> set;
   
   public void initialize(){
       set = new HashMap<Test>();
   }
}

```
「逸出(Escape)」:某个不应该发布的对象被发布时。

- 特殊示例： 即this引用在构造函数中逸出。常见错误是:在构造函数中启动一个线程

- 构造函数中注册一个事件监听器或启动线程，可以使用一个私有的构造函数和一个公共的工厂方法,从而避免不正确的构造

##### 3.2 线程封闭

定义: 在单线程内访问数据，不需要同步，也就是线程封闭(例如: JDBC连接池)

- 栈封闭: 将所有类型或对象都声明成局部变量，始终封闭在线程内。

- ThreadLocal类: 用于同一个线程内的方法 要共享某些变量或状态，提供线程内的局部变量。
 
  - Thread对象维护一个key以ThreadLocal的Map. 注意使用后要finally remove,防止内存泄露
  - 参考:https://juejin.im/post/5e5e1f876fb9a07ce31eefbc 
  